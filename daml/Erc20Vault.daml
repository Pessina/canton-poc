-- | Naming conventions follow Daml Finance / CIP-56 Canton Token Standard:
--   "issuer"       = the party that issues/manages the instrument
--   "Erc20Holding" = a holding (asset ownership) contract per CIP-56
module Erc20Vault where

import DA.Crypto.Text (BytesHex, PublicKeyHex)

import Types (EvmTransactionParams, MpcSignature(..))
import Crypto (computeRequestId, computeResponseHash, verifyMpcSignature)

-- | ERC-20 holding on Canton (per CIP-56 Canton Token Standard).
-- Represents a user's ownership of a wrapped ERC-20 token on a foreign chain.
template Erc20Holding
  with
    issuer       : Party  -- "issuer" per Daml Finance: the party that issues/manages the instrument
    owner        : Party
    erc20Address : BytesHex
    amount       : Decimal
  where
    signatory issuer
    observer owner

-- | A deposit that is waiting for MPC confirmation.
template PendingDeposit
  with
    issuer       : Party
    requester    : Party
    erc20Address : BytesHex
    amount       : Decimal
    requestId    : BytesHex
    evmParams    : EvmTransactionParams
  where
    signatory issuer
    observer requester

-- | A withdrawal that is waiting for MPC execution result.
template PendingWithdrawal
  with
    issuer           : Party
    requester        : Party
    erc20Address     : BytesHex
    amount           : Decimal
    recipientAddress : BytesHex
    requestId        : BytesHex
    evmParams        : EvmTransactionParams
  where
    signatory issuer
    observer requester

-- | Orchestrator contract that drives the deposit/withdraw state machine.
template VaultOrchestrator
  with
    issuer       : Party
    mpcPublicKey : PublicKeyHex
  where
    signatory issuer

    nonconsuming choice RequestDeposit : ContractId PendingDeposit
      with
        requester    : Party
        erc20Address : BytesHex
        amount       : Decimal
        evmParams    : EvmTransactionParams
      controller issuer, requester
      do
        let requestId = computeRequestId evmParams

        create PendingDeposit with
          issuer
          requester
          erc20Address
          amount
          requestId
          evmParams

    nonconsuming choice ClaimDeposit : ContractId Erc20Holding
      with
        pendingCid   : ContractId PendingDeposit
        mpcSignature : MpcSignature
        mpcOutput    : BytesHex
      controller issuer
      do
        pending <- fetch pendingCid
        archive pendingCid

        assertMsg "MPC public key mismatch"
          (mpcSignature.publicKey == mpcPublicKey)

        let responseHash = computeResponseHash pending.requestId mpcOutput

        assertMsg "Invalid MPC signature on deposit response"
          (verifyMpcSignature mpcSignature responseHash)

        create Erc20Holding with
          issuer
          owner = pending.requester
          erc20Address = pending.erc20Address
          amount = pending.amount

    nonconsuming choice RequestWithdrawal : (ContractId Erc20Holding, ContractId PendingWithdrawal)
      with
        requester        : Party
        balanceCid       : ContractId Erc20Holding
        recipientAddress : BytesHex
        withdrawAmount   : Decimal
        evmParams        : EvmTransactionParams
      controller issuer, requester
      do
        bal <- fetch balanceCid
        archive balanceCid

        assertMsg "Insufficient balance" (bal.amount >= withdrawAmount)

        let requestId = computeRequestId evmParams

        newBalCid <- create bal with amount = bal.amount - withdrawAmount

        pendingCid <- create PendingWithdrawal with
          issuer
          requester = bal.owner
          erc20Address = bal.erc20Address
          amount = withdrawAmount
          recipientAddress
          requestId
          evmParams

        pure (newBalCid, pendingCid)

    nonconsuming choice CompleteWithdrawal : Optional (ContractId Erc20Holding)
      with
        pendingCid   : ContractId PendingWithdrawal
        balanceCid   : ContractId Erc20Holding
        mpcSignature : MpcSignature
        mpcOutput    : BytesHex
      controller issuer
      do
        pending <- fetch pendingCid
        archive pendingCid

        assertMsg "MPC public key mismatch"
          (mpcSignature.publicKey == mpcPublicKey)

        let responseHash = computeResponseHash pending.requestId mpcOutput

        if verifyMpcSignature mpcSignature responseHash
          then
            pure None
          else do
            bal <- fetch balanceCid
            archive balanceCid
            refundCid <- create bal with amount = bal.amount + pending.amount
            pure (Some refundCid)
