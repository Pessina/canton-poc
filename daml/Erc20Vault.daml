module Erc20Vault where

import DA.Crypto.Text (BytesHex, PublicKeyHex)

import Types (EvmTransactionParams, MpcSignature(..))
import Crypto (computeRequestId, computeResponseHash, verifyMpcSignature)

-- | Per-user ERC-20 balance tracked on Canton.
-- Represents a holding of a wrapped token on a foreign chain.
template UserErc20Balance
  with
    operator     : Party
    owner        : Party
    erc20Address : BytesHex
    amount       : Decimal
  where
    signatory operator
    observer owner

-- | A deposit that is waiting for MPC confirmation.
template PendingDeposit
  with
    operator     : Party
    requester    : Party
    erc20Address : BytesHex
    amount       : Decimal
    requestId    : BytesHex
    evmParams    : EvmTransactionParams
  where
    signatory operator
    observer requester

-- | A withdrawal that is waiting for MPC execution result.
template PendingWithdrawal
  with
    operator         : Party
    requester        : Party
    erc20Address     : BytesHex
    amount           : Decimal
    recipientAddress : BytesHex
    requestId        : BytesHex
    evmParams        : EvmTransactionParams
  where
    signatory operator
    observer requester

-- | Orchestrator contract that drives the deposit/withdraw state machine.
template VaultOrchestrator
  with
    operator     : Party
    mpcPublicKey : PublicKeyHex
  where
    signatory operator

    nonconsuming choice RequestDeposit : ContractId PendingDeposit
      with
        requester    : Party
        erc20Address : BytesHex
        amount       : Decimal
        evmParams    : EvmTransactionParams
      controller operator, requester
      do
        let requestId = computeRequestId evmParams

        create PendingDeposit with
          operator
          requester
          erc20Address
          amount
          requestId
          evmParams

    nonconsuming choice ClaimDeposit : ContractId UserErc20Balance
      with
        pendingCid   : ContractId PendingDeposit
        mpcSignature : MpcSignature
        mpcOutput    : BytesHex
      controller operator
      do
        pending <- fetch pendingCid
        archive pendingCid

        assertMsg "MPC public key mismatch"
          (mpcSignature.publicKey == mpcPublicKey)

        let responseHash = computeResponseHash pending.requestId mpcOutput

        assertMsg "Invalid MPC signature on deposit response"
          (verifyMpcSignature mpcSignature responseHash)

        create UserErc20Balance with
          operator
          owner = pending.requester
          erc20Address = pending.erc20Address
          amount = pending.amount

    nonconsuming choice RequestWithdrawal : (ContractId UserErc20Balance, ContractId PendingWithdrawal)
      with
        requester        : Party
        balanceCid       : ContractId UserErc20Balance
        recipientAddress : BytesHex
        withdrawAmount   : Decimal
        evmParams        : EvmTransactionParams
      controller operator, requester
      do
        bal <- fetch balanceCid
        archive balanceCid

        assertMsg "Insufficient balance" (bal.amount >= withdrawAmount)

        let requestId = computeRequestId evmParams

        newBalCid <- create bal with amount = bal.amount - withdrawAmount

        pendingCid <- create PendingWithdrawal with
          operator
          requester = bal.owner
          erc20Address = bal.erc20Address
          amount = withdrawAmount
          recipientAddress
          requestId
          evmParams

        pure (newBalCid, pendingCid)

    nonconsuming choice CompleteWithdrawal : Optional (ContractId UserErc20Balance)
      with
        pendingCid   : ContractId PendingWithdrawal
        balanceCid   : ContractId UserErc20Balance
        mpcSignature : MpcSignature
        mpcOutput    : BytesHex
      controller operator
      do
        pending <- fetch pendingCid
        archive pendingCid

        assertMsg "MPC public key mismatch"
          (mpcSignature.publicKey == mpcPublicKey)

        let responseHash = computeResponseHash pending.requestId mpcOutput

        if verifyMpcSignature mpcSignature responseHash
          then
            pure None
          else do
            bal <- fetch balanceCid
            archive balanceCid
            refundCid <- create bal with amount = bal.amount + pending.amount
            pure (Some refundCid)
