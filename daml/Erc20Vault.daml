module Erc20Vault where

import DA.Crypto.Text (BytesHex, PublicKeyHex)

import Types (EvmTransactionParams, MpcSignature(..))
import Crypto (computeRequestId, computeResponseHash, verifyMpcSignature)

-- | Global vault configuration set once by the operator.
template VaultConfig
  with
    operator     : Party
    mpcPublicKey : PublicKeyHex
  where
    signatory operator

-- | Per-user ERC-20 balance tracked on Canton.
template UserErc20Balance
  with
    operator     : Party
    owner        : Party
    erc20Address : BytesHex
    amount       : Int
  where
    signatory operator
    observer owner

-- | A deposit that is waiting for MPC confirmation.
template PendingDeposit
  with
    operator     : Party
    requester    : Party
    erc20Address : BytesHex
    amount       : Int
    requestId    : BytesHex
    evmParams    : EvmTransactionParams
  where
    signatory operator
    observer requester

-- | A withdrawal that is waiting for MPC execution result.
template PendingWithdrawal
  with
    operator         : Party
    requester        : Party
    erc20Address     : BytesHex
    amount           : Int
    recipientAddress : BytesHex
    requestId        : BytesHex
    evmParams        : EvmTransactionParams
  where
    signatory operator
    observer requester

-- | Orchestrator contract that drives the deposit/withdraw state machine.
template VaultOrchestrator
  with
    operator     : Party
    mpcPublicKey : PublicKeyHex
  where
    signatory operator

    -- Request a deposit: compute requestId, create PendingDeposit.
    nonconsuming choice RequestDeposit : ContractId PendingDeposit
      with
        requester    : Party
        erc20Address : BytesHex
        amount       : Int
        evmParams    : EvmTransactionParams
      controller operator, requester
      do
        let requestId = computeRequestId evmParams
        create PendingDeposit with
          operator
          requester
          erc20Address
          amount
          requestId
          evmParams

    -- Claim a deposit: verify MPC signature, credit user balance.
    nonconsuming choice ClaimDeposit : ContractId UserErc20Balance
      with
        pendingCid   : ContractId PendingDeposit
        mpcSignature : MpcSignature
        mpcOutput    : BytesHex   -- serialized output from MPC (e.g. tx hash)
      controller operator
      do
        pending <- fetch pendingCid
        archive pendingCid

        -- The MPC must have signed with the vault's registered key.
        assertMsg "MPC public key mismatch"
          (mpcSignature.publicKey == mpcPublicKey)

        -- Verify signature over response_hash = keccak256(requestId || output).
        let responseHash = computeResponseHash pending.requestId mpcOutput
        assertMsg "Invalid MPC signature on deposit response"
          (verifyMpcSignature mpcSignature responseHash)

        create UserErc20Balance with
          operator
          owner = pending.requester
          erc20Address = pending.erc20Address
          amount = pending.amount

    -- Request a withdrawal: check balance, debit optimistically, create PendingWithdrawal.
    nonconsuming choice RequestWithdrawal : (ContractId UserErc20Balance, ContractId PendingWithdrawal)
      with
        requester        : Party
        balanceCid       : ContractId UserErc20Balance
        recipientAddress : BytesHex
        withdrawAmount   : Int
        evmParams        : EvmTransactionParams
      controller operator, requester
      do
        bal <- fetch balanceCid
        archive balanceCid

        assertMsg "Insufficient balance" (bal.amount >= withdrawAmount)

        let requestId = computeRequestId evmParams

        -- Optimistically debit.
        newBalCid <- create bal with amount = bal.amount - withdrawAmount

        pendingCid <- create PendingWithdrawal with
          operator
          requester = bal.owner
          erc20Address = bal.erc20Address
          amount = withdrawAmount
          recipientAddress
          requestId
          evmParams

        pure (newBalCid, pendingCid)

    -- Complete a withdrawal: verify signature. On failure (0xDEADBEEF), refund.
    nonconsuming choice CompleteWithdrawal : Optional (ContractId UserErc20Balance)
      with
        pendingCid   : ContractId PendingWithdrawal
        balanceCid   : ContractId UserErc20Balance
        mpcSignature : MpcSignature
        mpcOutput    : BytesHex
      controller operator
      do
        pending <- fetch pendingCid
        archive pendingCid

        assertMsg "MPC public key mismatch"
          (mpcSignature.publicKey == mpcPublicKey)

        let responseHash = computeResponseHash pending.requestId mpcOutput

        if verifyMpcSignature mpcSignature responseHash
          then
            -- Success: withdrawal confirmed on EVM side.
            pure None
          else do
            -- Failure: refund the debited amount.
            bal <- fetch balanceCid
            archive balanceCid
            refundCid <- create bal with amount = bal.amount + pending.amount
            pure (Some refundCid)
