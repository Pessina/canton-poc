module Test where

import DA.Optional (fromSome)
import DA.Crypto.Text
  ( keccak256
  , secp256k1WithEcdsaOnly
  , packHexBytes
  , byteCount
  , toHex
  , fromHex
  )
import Daml.Script

import Types
import Crypto
import Erc20Vault

------------------------------------------------------------------------
-- Test vectors (generated with openssl ecparam -name secp256k1)
------------------------------------------------------------------------

testPubKeyHex : Text
testPubKeyHex = "3056301006072a8648ce3d020106052b8104000a034200049b51a3db8f697ac5e49078b01af8d2721dd9a39b81c59bae57d13e5c5d4c915649441be47149b0293b28d8b4a92416045bb39f922329f197fdeed3320c0746a5"

testMessageHex : Text
testMessageHex = "1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8"

testSignatureHex : Text
testSignatureHex = "304602210093dffbc917a44aa1dd115ad85c5ddcfcda753490664a04802ac55028cea65b88022100acf58d3b62940b844872c1a156fc797499f823d9144ec2d05d21c71f901a3a3e"

------------------------------------------------------------------------
-- Helpers
------------------------------------------------------------------------

sampleEvmParams : EvmTransactionParams
sampleEvmParams = EvmTransactionParams with
  to = "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
  functionSignature = "transfer(address,uint256)"
  args = [ "000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045"
         , "0000000000000000000000000000000000000000000000000000000005f5e100"
         ]
  value = "0000000000000000000000000000000000000000000000000000000000000000"
  nonce = "0000000000000000000000000000000000000000000000000000000000000001"
  gasLimit = "000000000000000000000000000000000000000000000000000000000000c350"
  maxFeePerGas = "00000000000000000000000000000000000000000000000000000001dcd65000"
  maxPriorityFee = "000000000000000000000000000000000000000000000000000000003b9aca00"
  chainId = "0000000000000000000000000000000000000000000000000000000000aa36a7"

------------------------------------------------------------------------
-- Test 1: keccak256 known vector
------------------------------------------------------------------------

test1_keccak256KnownVector : Script ()
test1_keccak256KnownVector = do
  let input    = "68656c6c6f"
  let expected = "1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8"
  let result   = keccak256 input
  assertMsg ("keccak256 mismatch: got " <> result) (result == expected)

------------------------------------------------------------------------
-- Test 2: computeRequestId deterministic + 32 bytes
------------------------------------------------------------------------

test2_requestIdDeterministic : Script ()
test2_requestIdDeterministic = do
  let sender = "Issuer::1220abcdef"
  let caip2Id = "eip155:11155111"
  let path = "m/44/60/0/0"
  let id1 = computeRequestId sender sampleEvmParams caip2Id 1 path
  let id2 = computeRequestId sender sampleEvmParams caip2Id 1 path
  assertMsg "request_id must be deterministic" (id1 == id2)
  assertMsg ("request_id wrong length: " <> show (byteCount id1)) (byteCount id1 == 32)

------------------------------------------------------------------------
-- Test 3: computeResponseHash deterministic
------------------------------------------------------------------------

test3_responseHash : Script ()
test3_responseHash = do
  let sender = "Issuer::1220abcdef"
  let caip2Id = "eip155:11155111"
  let path = "m/44/60/0/0"
  let requestId = computeRequestId sender sampleEvmParams caip2Id 1 path
  let output    = "00000000000000000000000000000000000000000000000000000000deadbeef"
  let hash1     = computeResponseHash requestId output
  let hash2     = computeResponseHash requestId output
  assertMsg "response hash must be deterministic" (hash1 == hash2)
  assertMsg "response hash must be 32 bytes" (byteCount hash1 == 32)
  let hash3 = computeResponseHash requestId "00000000000000000000000000000000000000000000000000000000cafebabe"
  assertMsg "different output must give different hash" (hash1 /= hash3)

------------------------------------------------------------------------
-- Test 4: padHex / hex packing
------------------------------------------------------------------------

test4_hexPacking : Script ()
test4_hexPacking = do
  let packed = fromSome (packHexBytes "ff" 32)
  assertMsg "packed uint256 must be 32 bytes" (byteCount packed == 32)
  assertMsg "must be left-padded" (packed == "00000000000000000000000000000000000000000000000000000000000000ff")

  let addr = "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
  let packedAddr = fromSome (packHexBytes addr 20)
  assertMsg "20-byte address unchanged" (packedAddr == addr)

  let long = "0000000000000000000000001234567890abcdef1234567890abcdef12345678"
  let truncated = fromSome (packHexBytes long 20)
  assertMsg "truncation keeps rightmost bytes" (byteCount truncated == 20)

------------------------------------------------------------------------
-- Test 5: full deposit lifecycle (RequestEvmDeposit -> verify fields)
------------------------------------------------------------------------

test5_depositLifecycle : Script ()
test5_depositLifecycle = do
  issuer    <- allocateParty "Issuer"
  depositor <- allocateParty "Depositor"

  orchCid <- submit issuer do
    createCmd VaultOrchestrator with
      issuer
      mpcPublicKey = testPubKeyHex

  pendingCid <- submit (actAs issuer <> actAs depositor) do
    exerciseCmd orchCid RequestEvmDeposit with
      requester = depositor
      path      = "m/44/60/0/0"
      evmParams = sampleEvmParams

  pending <- queryContractId depositor pendingCid
  let pd = fromSome pending
  assertMsg "requestId must be 32 bytes" (byteCount pd.requestId == 32)
  assertMsg "path must match" (pd.path == "m/44/60/0/0")
  assertMsg "evmParams must match" (pd.evmParams == sampleEvmParams)

  pure ()

------------------------------------------------------------------------
-- Test 6: secp256k1 signature verification
------------------------------------------------------------------------

test6_secp256k1Verification : Script ()
test6_secp256k1Verification = do
  let valid = secp256k1WithEcdsaOnly testSignatureHex testMessageHex testPubKeyHex
  assertMsg "Valid signature must verify" valid

  let wrongMsg = keccak256 "deadbeef"
  let invalid = secp256k1WithEcdsaOnly testSignatureHex wrongMsg testPubKeyHex
  assertMsg "Wrong message must fail verification" (not invalid)

------------------------------------------------------------------------
-- Test 7: textToHex correctness
------------------------------------------------------------------------

test7_textToHex : Script ()
test7_textToHex = do
  assertMsg "ECDSA -> 4543445341" (textToHex "ECDSA" == "4543445341")
  assertMsg "ethereum -> 657468657265756d" (textToHex "ethereum" == "657468657265756d")
  assertMsg "eip155:1 -> 6569703135353a31" (textToHex "eip155:1" == "6569703135353a31")
  assertMsg "empty string -> empty" (textToHex "" == "")

------------------------------------------------------------------------
-- Test 8: chainIdToDecimalText correctness
------------------------------------------------------------------------

test8_chainIdToDecimalText : Script ()
test8_chainIdToDecimalText = do
  assertMsg "aa36a7 -> 11155111" (chainIdToDecimalText "aa36a7" == "11155111")
  assertMsg "01 -> 1" (chainIdToDecimalText "01" == "1")
  assertMsg "0000000000000000000000000000000000000000000000000000000000aa36a7 -> 11155111"
    (chainIdToDecimalText "0000000000000000000000000000000000000000000000000000000000aa36a7" == "11155111")
  assertMsg "single 1 -> 1" (chainIdToDecimalText "1" == "1")

------------------------------------------------------------------------
-- Test 9: uint32ToHex correctness
------------------------------------------------------------------------

test9_uint32ToHex : Script ()
test9_uint32ToHex = do
  assertMsg "1 -> 00000001" (uint32ToHex 1 == "00000001")
  assertMsg "0 -> 00000000" (uint32ToHex 0 == "00000000")
  assertMsg "255 -> 000000ff" (uint32ToHex 255 == "000000ff")
  assertMsg "65536 -> 00010000" (uint32ToHex 65536 == "00010000")

------------------------------------------------------------------------
-- Test 10: full claim lifecycle with valid MPC signature
------------------------------------------------------------------------

test10_claimLifecycle : Script ()
test10_claimLifecycle = do
  issuer    <- allocateParty "Issuer"
  depositor <- allocateParty "Depositor"

  orchCid <- submit issuer do
    createCmd VaultOrchestrator with
      issuer
      mpcPublicKey = testPubKeyHex

  pendingCid <- submit (actAs issuer <> actAs depositor) do
    exerciseCmd orchCid RequestEvmDeposit with
      requester = depositor
      path      = "m/44/60/0/0"
      evmParams = sampleEvmParams

  pending <- queryContractId depositor pendingCid
  let pd = fromSome pending

  let mpcOutput = "01"
  let responseHash = computeResponseHash pd.requestId mpcOutput

  outcomeCid <- submit issuer do
    exerciseCmd orchCid ProvideEvmOutcomeSig with
      requestId = pd.requestId
      signature = testSignatureHex
      mpcOutput

  submitMustFail issuer do
    exerciseCmd orchCid ClaimEvmDeposit with
      pendingCid
      outcomeCid
      amount = 100_000_000.0

  pure ()

------------------------------------------------------------------------
-- Test 11: built-in toHex / fromHex round-trips
------------------------------------------------------------------------

test11_builtinHexRoundTrips : Script ()
test11_builtinHexRoundTrips = do
  -- toHex Text matches expected UTF-8 encoding
  assertMsg "toHex ECDSA" (toHex "ECDSA" == "4543445341")
  assertMsg "toHex ethereum" (toHex "ethereum" == "657468657265756d")

  -- toHex Int produces 8-byte big-endian
  assertMsg "toHex Int 1" (toHex (1 : Int) == "0000000000000001")
  assertMsg "toHex Int 255" (toHex (255 : Int) == "00000000000000ff")

  -- fromHex round-trips for Int
  let decoded : Optional Int = fromHex "aa36a7"
  assertMsg "fromHex aa36a7" (decoded == Some 11155111)

  -- packHexBytes truncates 8-byte to 4-byte
  assertMsg "uint32 via packHexBytes"
    (fromSome (packHexBytes (toHex (1 : Int)) 4) == "00000001")

  pure ()
