module Test where

import DA.Optional (fromSome)
import DA.Crypto.Text
  ( keccak256
  , secp256k1WithEcdsaOnly
  , packHexBytes
  , byteCount
  )
import Daml.Script

import Types
import Crypto
import Erc20Vault

------------------------------------------------------------------------
-- Test vectors (generated with openssl ecparam -name secp256k1)
------------------------------------------------------------------------

testPubKeyHex : Text
testPubKeyHex = "3056301006072a8648ce3d020106052b8104000a034200049b51a3db8f697ac5e49078b01af8d2721dd9a39b81c59bae57d13e5c5d4c915649441be47149b0293b28d8b4a92416045bb39f922329f197fdeed3320c0746a5"

testMessageHex : Text
testMessageHex = "1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8"

testSignatureHex : Text
testSignatureHex = "304602210093dffbc917a44aa1dd115ad85c5ddcfcda753490664a04802ac55028cea65b88022100acf58d3b62940b844872c1a156fc797499f823d9144ec2d05d21c71f901a3a3e"

------------------------------------------------------------------------
-- Helpers
------------------------------------------------------------------------

sampleEvmParams : EvmTransactionParams
sampleEvmParams = EvmTransactionParams with
  erc20Address   = "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
  recipient      = "d8da6bf26964af9d7eed9e03e53415d37aa96045"
  amount         = "0000000000000000000000000000000000000000000000000000000005f5e100"
  nonce          = "0000000000000000000000000000000000000000000000000000000000000001"
  gasLimit       = "000000000000000000000000000000000000000000000000000000000000c350"
  maxFeePerGas   = "0000000000000000000000000000000000000000000000000000000ba43b7400"
  maxPriorityFee = "0000000000000000000000000000000000000000000000000000000077359400"
  chainId        = "0000000000000000000000000000000000000000000000000000000000000001"
  value          = "0000000000000000000000000000000000000000000000000000000000000000"
  operation      = Erc20Transfer

------------------------------------------------------------------------
-- Test 1: keccak256 known-vector
------------------------------------------------------------------------

test1_keccak256KnownVector : Script ()
test1_keccak256KnownVector = do
  let input    = "68656c6c6f"
  let expected = "1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8"
  let result   = keccak256 input
  assertMsg ("keccak256 mismatch: got " <> result) (result == expected)

------------------------------------------------------------------------
-- Test 2: request_id determinism
------------------------------------------------------------------------

test2_requestIdDeterministic : Script ()
test2_requestIdDeterministic = do
  let id1 = computeRequestId sampleEvmParams
  let id2 = computeRequestId sampleEvmParams
  assertMsg "request_id must be deterministic" (id1 == id2)
  assertMsg ("request_id wrong length: " <> show (byteCount id1)) (byteCount id1 == 32)

------------------------------------------------------------------------
-- Test 3: response hash
------------------------------------------------------------------------

test3_responseHash : Script ()
test3_responseHash = do
  let requestId = computeRequestId sampleEvmParams
  let output    = "00000000000000000000000000000000000000000000000000000000deadbeef"
  let hash1     = computeResponseHash requestId output
  let hash2     = computeResponseHash requestId output
  assertMsg "response hash must be deterministic" (hash1 == hash2)
  assertMsg "response hash must be 32 bytes" (byteCount hash1 == 32)
  let hash3 = computeResponseHash requestId "00000000000000000000000000000000000000000000000000000000cafebabe"
  assertMsg "different output must give different hash" (hash1 /= hash3)

------------------------------------------------------------------------
-- Test 4: hex packing
------------------------------------------------------------------------

test4_hexPacking : Script ()
test4_hexPacking = do
  let packed = fromSome (packHexBytes "ff" 32)
  assertMsg "packed uint256 must be 32 bytes" (byteCount packed == 32)
  assertMsg "must be left-padded" (packed == "00000000000000000000000000000000000000000000000000000000000000ff")

  let addr = "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
  let packedAddr = fromSome (packHexBytes addr 20)
  assertMsg "20-byte address unchanged" (packedAddr == addr)

  let long = "0000000000000000000000001234567890abcdef1234567890abcdef12345678"
  let truncated = fromSome (packHexBytes long 20)
  assertMsg "truncation keeps rightmost bytes" (byteCount truncated == 20)

------------------------------------------------------------------------
-- Test 5: full deposit lifecycle
------------------------------------------------------------------------

test5_depositLifecycle : Script ()
test5_depositLifecycle = do
  issuer  <- allocateParty "Issuer"
  depositor <- allocateParty "Depositor"

  orchCid <- submit issuer do
    createCmd VaultOrchestrator with
      issuer
      mpcPublicKey = testPubKeyHex

  pendingCid <- submit (actAs issuer <> actAs depositor) do
    exerciseCmd orchCid RequestDeposit with
      requester    = depositor
      erc20Address = sampleEvmParams.erc20Address
      amount       = 100_000_000.0
      evmParams    = sampleEvmParams

  pending <- queryContractId depositor pendingCid
  let pd = fromSome pending
  assertMsg "requestId must be 32 bytes" (byteCount pd.requestId == 32)

  let mpcOutput    = "aa"
  let responseHash = computeResponseHash pd.requestId mpcOutput
  let badSig = MpcSignature with
        signature = testSignatureHex
        publicKey = testPubKeyHex

  let verified = verifyMpcSignature badSig responseHash
  assertMsg "Signature over wrong message must fail" (not verified)

  pure ()

------------------------------------------------------------------------
-- Test 6: full withdrawal lifecycle (refund path)
------------------------------------------------------------------------

test6_withdrawalLifecycle : Script ()
test6_withdrawalLifecycle = do
  issuer <- allocateParty "Issuer"
  user     <- allocateParty "User"

  orchCid <- submit issuer do
    createCmd VaultOrchestrator with
      issuer
      mpcPublicKey = testPubKeyHex

  balCid <- submit issuer do
    createCmd Erc20Holding with
      issuer
      owner        = user
      erc20Address = sampleEvmParams.erc20Address
      amount       = 500_000_000.0

  (newBalCid, pendingCid) <- submit (actAs issuer <> actAs user) do
    exerciseCmd orchCid RequestWithdrawal with
      requester        = user
      balanceCid       = balCid
      recipientAddress = "d8da6bf26964af9d7eed9e03e53415d37aa96045"
      withdrawAmount   = 200_000_000.0
      evmParams        = sampleEvmParams

  newBal <- queryContractId user newBalCid
  assertMsg "Balance must be debited" ((fromSome newBal).amount == 300_000_000.0)

  let mpcOutput = "00000000000000000000000000000000000000000000000000000000deadbeef"
  let badSig = MpcSignature with
        signature = testSignatureHex
        publicKey = testPubKeyHex

  refundResult <- submit issuer do
    exerciseCmd orchCid CompleteWithdrawal with
      pendingCid
      balanceCid   = newBalCid
      mpcSignature = badSig
      mpcOutput

  case refundResult of
    None -> abort "Expected refund but got None"
    Some refundCid -> do
      refundBal <- queryContractId user refundCid
      assertMsg "Refund must restore balance" ((fromSome refundBal).amount == 500_000_000.0)

------------------------------------------------------------------------
-- Test 7: secp256k1 signature verification
------------------------------------------------------------------------

test7_secp256k1Verification : Script ()
test7_secp256k1Verification = do
  let valid = secp256k1WithEcdsaOnly testSignatureHex testMessageHex testPubKeyHex
  assertMsg "Valid signature must verify" valid

  let wrongMsg = keccak256 "deadbeef"
  let invalid = secp256k1WithEcdsaOnly testSignatureHex wrongMsg testPubKeyHex
  assertMsg "Wrong message must fail verification" (not invalid)
